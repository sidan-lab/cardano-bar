{
	"Aiken Minting Policy": {
		"prefix": "am",
		"body": [
			"use cardano/assets.{PolicyId}",
			"use cardano/transaction.{Transaction, placeholder}",
			"",
			"validator ${1:always_succeed} {",
			"    mint(_redeemer: Data, _policy_id: PolicyId, _tx: Transaction) {",
			"        True",
			"    }",
			"",
			"    else(_) {",
			"        fail @\"unsupported purpose\"",
			"    }",
			"}",
			"",
			"test test_$1_minting_policy() {",
			"    let data = Void",
			"    $1.mint(data, #\"\", placeholder)",
			"}"
		],
		"description": "Aiken minting policy boilerplate"
	},
	"Aiken Spending Validator": {
		"prefix": "as",
		"body": [
			"use aiken/collection/list",
			"use aiken/crypto.{VerificationKeyHash}",
			"use cardano/transaction.{OutputReference, Transaction}",
			"use mocktail.{",
			"    complete, mock_pub_key_hash, mock_utxo_ref, mocktail_tx, required_signer_hash,",
			"}",
			"",
			"pub type Datum {",
			"    owner: VerificationKeyHash,",
			"}",
			"",
			"pub type Redeemer {",
			"    msg: ByteArray,",
			"}",
			"",
			"validator ${1:hello_world} {",
			"    spend(",
			"        datum_opt: Option<Datum>,",
			"        redeemer: Redeemer,",
			"        _input: OutputReference,",
			"        tx: Transaction,",
			"    ) {",
			"        when datum_opt is {",
			"            Some(datum) -> {",
			"                let must_say_hello = redeemer.msg == \"Hello, World!\"",
			"                let must_be_signed = list.has(tx.extra_signatories, datum.owner)",
			"                must_say_hello? && must_be_signed?",
			"            }",
			"            None -> False",
			"        }",
			"    }",
			"",
			"    else(_) {",
			"        fail @\"unsupported purpose\"",
			"    }",
			"}",
			"",
			"fn mock_tx(is_owner_signed: Bool) -> Transaction {",
			"    mocktail_tx()",
			"        |> required_signer_hash(is_owner_signed, mock_pub_key_hash(0))",
			"        |> complete()",
			"}",
			"",
			"test test_$1() {",
			"    let datum = Datum { owner: mock_pub_key_hash(0) }",
			"    let redeemer = Redeemer { msg: \"Hello, World!\" }",
			"    let tx = mock_tx(True)",
			"    $1.spend(Some(datum), redeemer, mock_utxo_ref(0, 0), tx)",
			"}",
			"",
			"test test_failed_$1_incorrect_redeemer() {",
			"    let datum = Datum { owner: mock_pub_key_hash(0) }",
			"    let redeemer = Redeemer { msg: \"GM World!\" }",
			"    let tx = mock_tx(True)",
			"    !$1.spend(Some(datum), redeemer, mock_utxo_ref(0, 0), tx)",
			"}",
			"",
			"test test_failed_$1_without_signer() {",
			"    let datum = Datum { owner: mock_pub_key_hash(0) }",
			"    let redeemer = Redeemer { msg: \"Hello, World!\" }",
			"    let tx = mock_tx(False)",
			"    !$1.spend(Some(datum), redeemer, mock_utxo_ref(0, 0), tx)",
			"}"
		],
		"description": "Aiken spending validator boilerplate"
	},
	"Aiken Withdrawal Validator": {
		"prefix": "aw",
		"body": [
			"use aiken/crypto.{VerificationKeyHash}",
			"use cardano/address.{Credential, Script}",
			"use cardano/certificate.{Certificate}",
			"use cardano/transaction.{Transaction, placeholder}",
			"",
			"validator ${1:always_succeed}(_key_hash: VerificationKeyHash) {",
			"    withdraw(_redeemer: Data, _credential: Credential, _tx: Transaction) {",
			"        True",
			"    }",
			"",
			"    publish(_redeemer: Data, _credential: Certificate, _tx: Transaction) {",
			"        True",
			"    }",
			"",
			"    else(_) {",
			"        fail @\"unsupported purpose\"",
			"    }",
			"}",
			"",
			"test test_$1_withdrawal_policy() {",
			"    let data = Void",
			"    $1.withdraw(\"\", data, Script(#\"\"), placeholder)",
			"}"
		],
		"description": "Aiken withdrawal policy boilerplate"
	}
}